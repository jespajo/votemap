Finish off "seats won" bar chart.
    Add a label and dashed line showing the target value.
    Factor it out into a function.

UI features:
    Add polling booth mode where we show the name of the polling booth as the main title.
    In polling booth mode, show a 2CP chart just below the election name.
    In polling booth mode, show a FP chart below the 2CP chart.

Web server:
    Add stress tests.
    Make it multithreaded.

Improve labels.
    Merge serve_vertices() and serve_labels() on the backend so they make the same set of database queries.
    Make labels only exist in the data if the shapes they correspond to appear on the page.
    Add a couple of different styles to labels.json.
    Add cities and suburbs to the labels (depending on the zoom level).

When you tap on an electorate label:
    Map updates:
        Change to a flat-colour view of the map.
        Highlight the electorate bounds.
        Make the chosen electorate label bigger.
        Make the polling booths appear as circles.
        When you tap on one of the polling booths, it shows some details about it, including the particular result being shown.
    Panel updates:
        Show the electorate name as the main title, squashing the election title into one line above that.
        Add an X next to the electorate name (or something) to allow going back to the previous mode.

Redo the maps and topology.
    Cut out rivers from the coastline.
    Make sure Franklin exists.

Database schema changes:
    Add party_id columns to the votes tables, to allow joining with the parties without needing the candidate table middle man.
    Add updated_at columns to the votes tables.

Why does clicking on Lingiari specifically result in showing a much larger area than expected?

Figure out what to do about our RAM slowly filling up with cached SQL queries.

In the default view, below the overall results chart in the panel, add a list of all electorates and allow tapping on them to go into that electorate's view.

Add swing mode.
    The polling booths should show the percentage swing for each result.
    The map should add an extra line showing the old bounds.

Further improve labels.
    Update the label placer so that labels only occupy those tiles they actually touch when the map is rotated.
    Add some labels to roads and rivers.

Web server:
    Use getaddrinfo().
    Support IPv6.
    Parse request headers.
    Parse request bodies; support POST requests.
    Support Connection: Keep-Alive.
    Support Windows.

Front end: draw map legend scale (e.g. show a line equal to 5km for reference).

Front end: draw compass.
    On mobile, tap this to return to a view with north oriented upwards.
    On desktop, when you press the compass you go into rotation mode. A circle appears in the middle of the screen with the compass directions etched in. Your cursor is on the edge of the compass. A change in the cursor image would be nice. While the mouse is held down, the circle rotates such that the point the cursor was originally on is the closest point on the circle to the cursor position.

---

|Bug: http://tmp.tal:6008/bin/vertices?&x0=1245681.9351063075&y0=3384238.725323079&x1=1809330.036574922&y1=4044415.7830911092&upp=675.0276664294785 fails is_polygon() assert.

In polling booth mode, when you hover/tap on the relevant places on the 2CP and FP charts, update the polling-booth circles appropriately.
In the default mode, when you hover/tap on the relevant places on the overall election results chart, visualise the FP results for just that party on the map.

serve_file_slowly():
    Better than what we're doing would be: When the server starts up, recursively visit all files under the working directory and put their full paths into a big array. Also keep track of whether each one is a regular file or a directory. Keep the array sorted for quick searching. Then if the request path matches a path in the array, we know it's a valid file, so we'll try to load it into memory. Then you can do the normalisation of the URL (i.e. making '..' mean to go up a directory) in a separate function, which would simply take the request path as an argument and return the normalised path. This would be much quicker as we wouldn't need to make a thousand syscalls to serve every single file!
    My main question is: if we're going to cache the files under our directory, when and how do we update this cache? Ideally---for as long as we're single-threaded---we would never update the cache until we've dealt with all pending requests. Then we would update it as soon as possible after that.
