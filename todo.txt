Add the actual colours to the Voronoi map.
2. Create another table candidates_22 associating candidate IDs with party IDs.
3. Associate party IDs with colours in the C application---this way we can think about doing things like using stripes of two colours to represent some parties.
4. Update your booths query so that it returns the party ID of the candidate with the most first preferences for each booth.

Add cities/suburbs to labels depending on zoom level

---

Turn the electorate edge data (currently topo being queried) into geometry so we can index it and also so we can associate lines with names when they are things like rivers, etc.

Get the front end to request the vertices in a predictable grid of tiles

triangulate_polygon():
    Speed up with spatial hashing?

|Bug: Sometimes the web server to was failing to close the socket for the request for labels.json. It hasn't happened in a while though.

serve_file_slowly():
    Better than what we're doing would be: When the server starts up, recursively visit all files under the working directory and put their full paths into a big array. Also keep track of whether each one is a regular file or a directory. Keep the array sorted for quick searching. Then if the request path matches a path in the array, we know it's a valid file, so we'll try to load it into memory. Then you can do the normalisation of the URL (i.e. making '..' mean to go up a directory) in a separate function, which would simply take the request path as an argument and return the normalised path. This would be much quicker as we wouldn't need to make a thousand syscalls to serve every single file!
    My main question is: if we're going to cache the files under our directory, when and how do we update this cache? Ideally---for as long as we're single-threaded---we would never update the cache until we've dealt with all pending requests. Then we would update it as soon as possible after that.

Write up database schema plan docs/database.txt.
Upload XML files to database:
    polling booth info
    candidate info
    vote data
    election info

|Bug: I left my computer with the current build open in the browser for a few hours and when I tried scrolling the mouse, it was super janky, like the transformations weren't being applied uniformly. I stupidly refreshed the page. The fact that it appeared after a while made me thing it was floating-point issues to do with currentTime being large, but I haven't been able to reproduce the issue by setting currentTime to large values.

Front end: improve two-part transitions.
    Only do them if you're going from one zoomed-in look to another in a different place?
    Expand the combined bounds box?
    Use some kind of spline!?

Front end: draw map legend scale (e.g. show a line equal to 5km for reference).

Further label improvements:
    There is still a bug where labels on one edge of the grid wrap around and fill grid squares on the other side. |Bug
    Get the grid to make use of the screen space efficiently.
    Get the labels to take up only the grid squares they actually touch, even when the map is rotated.
    At the moment, our secret (or cheat) to making it look so stable is that the algorithm breaks as soon as it can't find space for one label on the map. It doesn't keep looking. Really we do want it to keep looking and to fill the available space with labels---up to a point: we don't want it to label one small random electorate in a cluster of unlabelled electorates...
    In fact, what we mainly don't want, I think, is for labels to extend beyond the borders of their electorates. E.g. Eden-Monaro, being a long electorate name, shouldn't appear until it actually fits. Two ways to get this result come to mind: add a bounding box to each label, and add a single value, a width, to each label. In either case you'd only show the label if the width exceeds the map-space width of the text box. So if we can stop electorate labels from exceeding the geographic span of their districts, it might also solve the problem of showing a single electorate in a cluster.
    Also if we cache the currently-shown labels and rate-limit how often we change this set, we could performance and perceived stability, and even improve the result, because if it's not running every frame we could increase the resolution.
    Ultimately, the way to get truly great results will be by implementing a label-override system. Each thing being labelled would have an ID. The source code includes, as JSON text, a list of IDs and their corresponding overridden label attributes. Then we implement an editor on the front end that will let us move the labels around and export their current state as JSON. Bingo bango bongo.

Front end: draw compass.
    On mobile, tap this to return to a view with north oriented upwards.
    On desktop, when you press the compass you go into rotation mode. A circle appears in the middle of the screen with the compass directions etched in. Your cursor is on the edge of the compass. A change in the cursor image would be nice. While the mouse is held down, the circle rotates such that the point the cursor was originally on is the closest point on the circle to the cursor position.

Web server:
    Use getaddrinfo().
    Support IPv6.
    Parse request headers.
    Parse request bodies; support POST requests.
    Make it multithreaded.
    Support Connection: Keep-Alive.
