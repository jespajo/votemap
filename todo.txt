Write up database schema plan docs/database.txt.
Upload XML files to database:
    polling booth info
    candidate info
    vote data
    election info

Make Voronoi map visualise real vote data instead of random colours.

|Bug: I left my computer with the current build open in the browser for a few hours and when I tried scrolling the mouse, it was super janky, like the transformations weren't being applied uniformly. I stupidly refreshed the page. The fact that it appeared after a while made me thing it was floating-point issues to do with currentTime being large, but I haven't been able to reproduce the issue by setting currentTime to large values.

Write up docs on map params:
    bounds
    zoom levels
    layers
Get main() to call a function that returns different verts depending on bounds, zoom level and layer.
Get JavaScript just to request based on the current zoom level when you press a key.
Turn main() into a CGI script that parses this and returns the verts to the web browser.

Front end: improve two-part transitions.
    Only do them if you're going from one zoomed-in look to another in a different place?
    Expand the combined bounds box?
    Use some kind of spline!?

Front end: draw map legend scale (e.g. show a line equal to 5km for reference).

triangulate_polygon():
    Return Triangle_array instead of Path_array. It will be faster and also make more sense because the output of triangulate_polygon doesn't follow the rules for Path structs, namely, repeat the first point in closed rings and make sure the points are in anticlockwise order to define a positive space.
    Identify holes: turn the polygon into one big ring?
    Use spatial hashing to speed it up.

Further label improvements:
    There is still a bug where labels on one edge of the grid wrap around and fill grid squares on the other side. |Bug
    Get the grid to make use of the screen space efficiently.
    Get the labels to take up only the grid squares they actually touch, even when the map is rotated.
    At the moment, our secret (or cheat) to making it look so stable is that the algorithm breaks as soon as it can't find space for one label on the map. It doesn't keep looking. Really we do want it to keep looking and to fill the available space with labels---up to a point: we don't want it to label one small random electorate in a cluster of unlabelled electorates...
    In fact, what we mainly don't want, I think, is for labels to extend beyond the borders of their electorates. E.g. Eden-Monaro, being a long electorate name, shouldn't appear until it actually fits. Two ways to get this result come to mind: add a bounding box to each label, and add a single value, a width, to each label. In either case you'd only show the label if the width exceeds the map-space width of the text box. So if we can stop electorate labels from exceeding the geographic span of their districts, it might also solve the problem of showing a single electorate in a cluster.
    Also if we cache the currently-shown labels and rate-limit how often we change this set, we could performance and perceived stability, and even improve the result, because if it's not running every frame we could increase the resolution.
    Ultimately, the way to get truly great results will be by implementing a label-override system. Each thing being labelled would have an ID. The source code includes, as JSON text, a list of IDs and their corresponding overridden label attributes. Then we implement an editor on the front end that will let us move the labels around and export their current state as JSON. Bingo bango bongo.

Front end: draw compass.
    On mobile, tap this to return to a view with north oriented upwards.
    On desktop, when you press the compass you go into rotation mode. A circle appears in the middle of the screen with the compass directions etched in. Your cursor is on the edge of the compass. A change in the cursor image would be nice. While the mouse is held down, the circle rotates such that the point the cursor was originally on is the closest point on the circle to the cursor position.

C framework: copy_string() (and others?) should take optional length params so they don't have to calculate their length unless needed. Optional probably means calling them with -1 for the length argument to say, "These strings are NULL-terminated. Find the length yourself." Add this argument then audit uses of these functions to pass the length if we already know it.

C framework: I can never decide whether to use char or u8 for data. u8 feels better but we can't call print_string() on it. Maybe we could achieve this if we turn print_string() into a macro that calls a function, print_string_((ARRAY)->data, (ARRAY)->count, ...). The first argument is a char *. I think the compiler might be fine with implicitly casting a u8 * to a char * in that case? Or if we have to make it void *, can we assert(sizeof((ARRAY)->data[0]) == sizeof(char))?

Web server:
    serve_file() should not support following symlinks or going up a directory with '..'.
    Parse request headers.
    Parse request bodies; support POST requests.
    Make it multithreaded.
