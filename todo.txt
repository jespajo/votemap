---

Stabilise label-maker algorithm:
    1. Get the screen bounding box in map-space coordinates as four points.
    2. Make a note of the X and Y domains of these four points. This whole big rectangle becomes our area of focus.
    3. Decide the grid size---it will be a power of two---based on how many squares of that size we need to cover the rectangle. We want the smallest grid size possible while still covering the rectangle with no more than `resolution` squares.
    4. In fact, this rectangle---the one made of grid squares, which is most likely slightly larger than the rectangle that envelopes our screen's bounding quad---becomes our real grid of focus. From now on we can turn XY coordinates into an index in the usedSpace buffer by finding `Math.floor(((y-gridRect.y)/numGridRows)*numGridCols + (x-gridRect.x)/numGridCols)`.
    5. When we go to draw a label:
       a. Find its bounding box in map-space coordinates. Skip it if it's outside our grid.
       b. Sort the points of the bounding box by Y. Call the sorted points A, B, C and D.
       c. Iterate over the grid rows in the Y-range of A, B, C and D.
          i. To start with, track the lines AB and AC. On each pass, find the X values of these lines. These become our X-range. When we get to the Y value of B, our lines become AC and BD. When we get to the Y value of C, our lines become BD and CD.
          ii. Turn each square in the grid within the X range into a usedSpace buffer index. If the byte at this index has been set already, cancel the label, set `used = true`.
       d. If we get this far and `used` is still false, iterate over the grid rows in the same way as before, but this time, set all the bytes in the usedSpace buffer.

Old ideas for label-maker improvements:
    Fix bug where labels rendered on one side of the screen wrap around and fill boxes in the used-space grid on the other side of the screen.
    Keep a cached array of labels that you keep referring to each frame unless a dirty flag is set. Set the flag if the map's scale or rotation has changed, or the translation has changed beyond a threshold.
    To make it appear more stable when zooming/rotating, debounce setting the dirty flag.
    Get it to keep trying to find room for new labels after failing once but not to keep trying indefinitely. It starts to look weird if we label one tiny electorate in a dense cluster of unlabelled electorates.

---

Redo the Voronoi diagram with topological data.
Finish writing docs/topology.md.

Write up database schema plan docs/database.txt.
Upload XML files to database:
    polling booth info
    candidate info
    vote data
    election info

Make Voronoi map visualise real vote data instead of random colours.

@Bug: I left my computer with the current build open in the browser for a few hours and when I tried scrolling the mouse, it was super janky, like the transformations weren't being applied uniformly. I stupidly refreshed the page. The fact that it appeared after a while made me thing it was floating-point issues to do with currentTime being large, but I haven't been able to reproduce the issue by setting currentTime to large values.

Write up docs on map params:
    bounds
    zoom levels
    layers
Get main() to call a function that returns different verts depending on bounds, zoom level and layer.
Get JavaScript just to request based on the current zoom level when you press a key.
Turn main() into a CGI script that parses this and returns the verts to the web browser.

Front end: improve two-part transitions.
    Only do them if you're going from one zoomed-in look to another in a different place?
    Expand the combined bounds box?
    Use some kind of spline!?

Front end: draw map legend scale (e.g. show a line equal to 5km for reference).

Front end: draw compass.
    On mobile, tap this to return to a view with north oriented upwards.
    On desktop, when you press the compass you go into rotation mode. A circle appears in the middle of the screen with the compass directions etched in. Your cursor is on the edge of the compass. A change in the cursor image would be nice. While the mouse is held down, the circle rotates such that the point the cursor was originally on is the closest point on the circle to the cursor position.

Front end: proper FPS counter.

triangulate_polygon():
    Return Triangle_array instead of Path_array. It will be faster and also make more sense because the output of triangulate_polygon doesn't follow the rules for Path structs, namely, repeat the first point in closed rings and make sure the points are in anticlockwise order to define a positive space.
    Identify holes: turn the polygon into one big ring?
    Use spatial hashing to speed it up.
